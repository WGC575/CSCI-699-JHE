\section{Commit Types}
\label{sec:type}
\subsection{A Refined Categorization}
\begin{table}[htbp]
  \centering
  \caption{Refined Categorization}
    \begin{tabular}{|p{6em}|p{9em}r|}
    \hline
    Type  & \multicolumn{1}{p{9em}|}{Hindle's Definition} & \multicolumn{1}{p{12.5em}|}{Our Explanation} \\
    \hline
    Branch & \multicolumn{2}{p{21.5em}|}{If the change is primarily to do with branching or working off the main development trunk of the version control system.} \\
    \hline
    Bug fix & \multicolumn{1}{p{9em}|}{One or more bug fixes.} & \multicolumn{1}{p{12.5em}|}{A change that is reported in the developing log, change log or with expressions in commit message that indicates it is a correction of unexpected behavior.} \\
    \hline
    Build & \multicolumn{2}{p{21.5em}|}{If the focus of the change is on the build or configuration system files. (such as Makefiles).} \\
    \hline
    Clean up & \multicolumn{2}{p{21.5em}|}{Cleaning up the source code or related files. This includes activities such as removing non-used functions.} \\
    \hline
    Legal & \multicolumn{2}{p{21.5em}|}{A change of license, copyright or authorship.} \\
    \hline
    Cross & \multicolumn{2}{p{21.5em}|}{A cross cutting concern is addressed (like logging).} \\
    \hline
    Data  & \multicolumn{2}{p{21.5em}|}{A change to data files required by the software (different from a change to documentation).} \\
    \hline
    Debug & \multicolumn{2}{p{21.5em}|}{A commit that adds debugging code.} \\
    \hline
    Documentation & \multicolumn{2}{p{21.5em}|}{A change to the system's documentation.} \\
    \hline
    External & \multicolumn{2}{p{21.5em}|}{Code that was submitted to the project by developers who are not part of the core team of the project.} \\
    \hline
    Feature Add & \multicolumn{1}{p{9em}|}{An addition/implementation of a new feature.} & \multicolumn{1}{p{12.5em}|}{New function/methods/class implemented, impacting functionality.} \\
    \hline
    Indentation & \multicolumn{2}{p{21.5em}|}{Re-indenting or reformatting of the source code.} \\
    \hline
    Initialization & \multicolumn{2}{p{21.5em}|}{A module being initialized or imported (usually one of the first commits to the project).} \\
    \hline
    Internationa- lization & \multicolumn{2}{p{21.5em}|}{A change related to its support for languages other-than-English.} \\
    \hline
    Source Control & \multicolumn{2}{p{21.5em}|}{A change that is the result of the way the source controls system works, or the features provided to its users (for example, tagging a snapshot).} \\
    \hline
    Maintenance & \multicolumn{1}{p{9em}|}{A commit that performs activities common during maintenance cycle (different from bug fixes, yet, not quite as radical as new features).} & \multicolumn{1}{p{12.5em}|}{Functional changes without feature add and do not have evidence to be considered a bug fix, including performance Improvement and feature extension.} \\
    \hline
    Merge & \multicolumn{2}{p{21.5em}|}{Code merged from a branch into the main trunk of the version control system; it might also be the result of different and non-necessarily related changes committed simultaneously to the version control system.} \\
    \hline
    Module Add & \multicolumn{2}{p{21.5em}|}{If a module (directory) or files have been added to a project.} \\
    \hline
    Module Move & \multicolumn{2}{p{21.5em}|}{When a module or files are moved or renamed.} \\
    \hline
    Module Remove & \multicolumn{2}{p{21.5em}|}{Deletion of module or files.} \\
    \hline
    {Platform Specific} & \multicolumn{2}{p{21.5em}|}{A change needed for a specific platform (such as different hardware or operating system).} \\
    \hline
    Refactoring & \multicolumn{1}{p{9em}|}{Refactoring of portions of the source code.} & \multicolumn{1}{p{12.5em}|}{Relocation of part of code. Restructuring.
    Extract a part of code out of a function and create a new function.} \\
    \hline
    Rename & \multicolumn{2}{p{21.5em}|}{One or more files are renamed, but remain in the same module (directory).} \\
    \hline
    Testing & \multicolumn{2}{p{21.5em}|}{A change related to the files required for testing or benchmarking.} \\
    \hline
    Token Replace & \multicolumn{2}{p{21.5em}|}{An token (such as an identifier) is renamed across many files (e.g. change the name or a function).} \\
    \hline
    Versioning & \multicolumn{2}{p{21.5em}|}{A change in version labels of the software (such as replacing ``2.0'' with ``2.1'').} \\
    \hline
    \end{tabular}%
  \label{tab:categorization}%
\end{table}%





\subsection{The Specification for Hindle's categorization}
To analyze the difference in purpose between breakers and neutrals, we need an accurate categorization for commits.
Although we leverage Hindle's categorization, it was originally designed for usage only on large commits.
Several change types such as Maintenance, Bug Fix, Debug and Refactoring were too broadly defined when applied to smaller commits, and at times needed to be accompanied by other categories to fully classify the commit change.

Our analysis leads to a refinement of Hindle's categories, and the identification of the commits that warrant defining new categories for comprehensive classification.
These modifications result in variations in category frequency from those found by Hindle et al. \cite{Hindle_cate}. This indicates, in part, significant changes in category definitions. For example, out of the 2000 commits that they analyzed, 2\% were tagged as maintenance while in our analysis it's more than 40\%.
This result is surprising, as other studies  \cite{dodaro2015government,redman2008weapon,koskinen2009software} report that 75\% of software development budgets are dedicated to maintenance. Another contributing factor for the variation in category frequency is our inclusion of small commits. Along with the new taxonomy, we provide results that describe the relationship between commit size and purpose.

Table \ref{tab:categorization} shows the refined taxonomy.
Specifications for types are as follows:

\textbf{Bug Fix:} In small commits, the lack of descriptive code makes it hard to differentiate between Bug Fix and Maintenance categorization. 
As a result, we have to rely on commit messages and project change logs. 
For example, if a commit message mentions fixing an existing issue, it should be tagged a Bug Fix. We also thoroughly examine previous software revisions, to see if the commit is added in response to flaws in recent code.
While we take these steps to better identify Bug Fixes, some commits are still too vague to be clearly tagged Maintenance or Bug Fix. 
Further improvement and definition of rules are needed to make the tagging more definitive on small commits.

\textbf{Feature Add:} We found that Hindle's definition of a Feature Add is under-specified for smaller commits.
This may be because new features are easily identifiable in larger commits via the commit message, whereas in small code changes, new features can be a single non-utility function or method. We include this in our refined definition of Feature Add.

\textbf{Maintenance:} This is the most under-specified type in the original taxonomy.
As shown in Fig. \ref{fig:cross_validation}, more than half of the commits with inconsistent tags are with Maintenance. 
Thus, we consult with Hindle et al. regarding this tag.
According to our discussion, this should be better translated to ``minor perfective changes'' which is different from the maintenance tasks we generally use.
Since the original definition can cause confusion due to little specification, we define it as function \& efficiency improvements, additions of utility functions, or minor modifications without new methods or error corrections.
For example, memory cleaning is tagged as Maintenance because it is a performance improvement. 


\textbf{Refactoring:} 
We specify Refactoring as relocation, restructuring of code without altering how the code functions, such as extracting code to form a new function, relocating code hunks within or across files, or other changes to reduce code redundancies.
They do not change functionality or efficiency.

Note that by our definition, breakers and neutrals can not be merge or orphan commits, as we study the impact of a commit by comparing two revisions: the one it changes and the one it produces.
As a result, there are no commits in the Branch and Initialization categories.
\subsection{The Difference Between Categories with Respect to Software Quality}
